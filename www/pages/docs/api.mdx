# API Reference

`HybricEditor` is the main entry point of `hybricmark`.
It is built on top of Tiptap, with block IDs and Typora-like interactions enabled by default.

## `<HybricEditor />` Props

| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `content` | `string \| JSON` | `undefined` | Initial content. Supports Markdown/HTML string input or a Tiptap JSON document tree. |
| `editable` | `boolean` | `true` | Enables or disables editing mode. |
| `placeholder` | `string` | `"Type '/' for commands..."` | Placeholder text for empty documents. |
| `className` | `string` | `undefined` | Custom classes for the editor root wrapper. |
| `extensions` | `Extension[]` | `[]` | Additional Tiptap extensions merged into HybricMark defaults. |
| `editorProps` | `EditorProps` | `undefined` | Native ProseMirror/Tiptap editor props (e.g. `handleKeyDown`, `handlePaste`). |
| `onChange` | `(editor: Editor) => void` | `undefined` | Compatibility callback. Fires on update and returns the editor instance. |
| `onUpdate` | `({ editor, transaction }) => void` | `undefined` | Fires on each editor transaction. Useful for immediate UI sync. |
| `onDebouncedUpdate` | `(editor: Editor) => void` | `undefined` | Recommended for database persistence to avoid high-frequency writes. Internally receives `{ editor, transaction }`; use `editor` in save logic. |
| `debounceMs` | `number` | `400` | Debounce interval used by `onDebouncedUpdate`. |
| `onExtract` | `(data) => void` | `undefined` | Triggered by "Extract to Card" actions in context menu. |

> **Why `onDebouncedUpdate` matters**  
> Saving on every keystroke can flood your API and increase contention on collaborative/stateful backends. Debounced saving is safer and cheaper.

## Editor Instance Methods

The callback gives you full access to the Tiptap `editor` instance.

```ts
// Command chaining
editor.chain().focus().toggleBold().run()

// Read current state
editor.getJSON()
editor.getHTML()

// Programmatic actions
editor.commands.clearContent()
editor.commands.focus()
```

## Data Structure: Unique Block IDs

Every block node carries an `attrs.id`, enabling block-level references and granular persistence.

```json
{
  "type": "doc",
  "content": [
    {
      "type": "paragraph",
      "attrs": {
        "id": "uuid-1234"
      },
      "content": [
        { "type": "text", "text": "Hello HybricMark" }
      ]
    },
    {
      "type": "heading",
      "attrs": {
        "id": "uuid-5678",
        "level": 2
      },
      "content": [
        { "type": "text", "text": "Block-level updates" }
      ]
    }
  ]
}
```

> **Block IDs vs plain Markdown**  
> Traditional Markdown is line/text-oriented; it does not guarantee stable block identity.  
> HybricMark's UUID-backed blocks let you do Notion-style features: block comments, per-block sync, and targeted update patches.

## Practical Extension Setup

```tsx
import CharacterCount from '@tiptap/extension-character-count'
import { HybricEditor } from 'hybricmark'

<HybricEditor
  content="# Title"
  extensions={[CharacterCount.configure({ limit: 10000 })]}
  editorProps={{
    handleKeyDown: (_view, event) => {
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's') {
        event.preventDefault()
        return true
      }
      return false
    },
  }}
/>
```
